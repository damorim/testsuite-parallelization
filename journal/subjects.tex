\section{Objects of Analysis}
\label{sec:subjects}

We used \github{}'s search API~\cite{githubsearch} to identify
projects that satisfy the following criteria: (1) the primary language
is Java\footnote{In case of projects in multiple languages, the
  \github{} API considers the predominant language as the primary
  language.}, (2) the project has at least 100 stars, and (3) the latest
update was on or after \Jbc{January 1st, 2017}.
Although there is no clearcut limit on the number of \github{}
stars~\cite{github-stars} to define relevant projects, we observed that one
hundred stars was enough to eliminate trivial subjects.
The third criteria serves to skip projects without recent activity.
\Jbc{We focused on Java for its popularity.
It is important to highlight that the \github{}'s search API imposes a limit of
returning only the top 1000 results for a single query.
To overcome this limitation and have a larger sample set, we divided our
original query into multiple queries over subsequent periods of time and
considered the union the results.}
% Important to highlight that, as of now, the \github{}'s search API can only
% reflect contents from repository statistics (\eg, number of forks, main
% programming language); it does not provide a feature to search for projects
% containing certain files (\eg{}, \emph{pom.xml}) in the directory structure.
Figure~\ref{fig:subject-query} illustrates a query to the \github{} API as
an HTTP request.

\begin{figure}[t!]
\centering
\tiny
\lstset{
    escapeinside={@}{@},
    numbers=left,xleftmargin=1em,frame=single,framexleftmargin=0.5em,
    basicstyle=\ttfamily\scriptsize, boxpos=c, numberstyle=\tiny,
    showstringspaces=false
}
\begin{lstlisting}
https://api.github.com/search/repositories?q=language:java
 +stars:>=100+pushed:2017-01-01..2017-02-01&page=1
\end{lstlisting}
  \vspace{-3mm}
  \caption{\label{fig:subject-query} Query to the \github{} API for projects
  that (1) use Java, (2) contains at least 100 stars, (3) has been updated
  between January 1st and February 1st of 2017.}
  \vspace{-5mm}
\end{figure}

We used the following methodology to select projects for analysis.
After obtaining the list of potential projects from GitHub, we filtered those
with Maven support (\ie, contains a \pomf{} file in the root directory).
We focused on Maven for its popularity in Java projects.
Then, considering this set of Maven projects, we executed the tests for
\SubjectsReruns{} times to discard those projects with issues in the build file
and non-deterministic results observed from sequential executions.

As of December 12th 2017, our search criteria returned a total of
\SubjectsGithub{} projects, and we identified \SubjectsMaven{} Maven projects.
\Fix{From this set of projects, \SubjectsGithubNotTestable{} projects were not
considered because of environment incompatibility (\eg, missing DBMS) and
\SubjectsGithubFlaky{} projects were discarded because of ``flaky
tests''~\cite{luo-etal-fse2014}.
A ``flaky'' test is a test that passes or fails under the same circumstances
leading to non-deterministic results.  As some of our experiments consist of
running tests on different threads, we ignored these projects as it would be
impractical to identify whether a test failed due to a race condition or some
other source of flakiness.
From the remaining \SubjectsGithubConsistant{} projects with deterministic
results, we eliminated \SubjectsGithubTooManyFailures{} projects with
\SuiteFailingThreshold{} or more failing tests as to reduce bias.
For the remaining projects with failing tests, we used the JUnit's
\CodeIn{@Ignore} annotation to ignore failing tests.
Our final set of subjects
contains \numSubjs{} projects.
Figure~\ref{fig:subjects} summarizes our sample set.}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.27\textwidth]{results/piechart-subjs.pdf}
  \caption{\label{fig:subjects}We fetched \SubjectsGithub{} popular projects
  hosted on \github{}. From this initial sample, we ignored
  \SubjectsGithubNotMaven{} projects without Maven support,
  \SubjectsGithubNotTestable{} with missing dependencies,
  \SubjectsGithubFlaky{} projects with flaky tests, and
  \SubjectsGithubTooManyFailures{} projects had at least
  \SuiteFailingThreshold{} of failing tests. We considered
  \numSubjs{} projects to conduct our study.}
\end{figure}

\label{sec:setup}
To run our experiments, we used a Core i7-4790 (3.60 GHz) Intel processor
machine with eight virtual CPUs (four cores with two native threads each) and
16GB of memory, running Ubuntu 14.04 LTS Trusty Tahr (64-bit version).
We used Java 8 and Maven 3.5.2 to build projects and run test suites.  To
process test results and generate plots we used Python, Bash, R and Ruby.
All source artifacts are publicly available for replication on our
website~\cite{ourwebpage}.
This includes supporting scripts and the full list of projects.

