\section{Introduction}

%% . which can disrupt the development
%% process~\cite{hilton-etal-ase2016}.\Comment{  This is often referred to as the
%% ``regression testing problem''.}

As software evolves it is expected that the number of tests and the
length of test runs increase.  Both components can add up to the
aggregate cost of running a test suite.  Dealing with high testing
costs is an important problem in software engineering research and
practice (as to reduce late test failure reports).

Several approaches have been proposed in the research literature to
address the regression testing problem, with the focus mainly on test
suite minimization, prioritization, reduction, and
selection~\cite{yoo-harman-stvr2012}.  In industry, the focus has been
mainly on distributing the testing workloads.  Evidence of this are
the Google TAP system~\cite{google-tap,google-ci} and Microsoft's
CloudBuild system~\cite{prasad-shulte-ieee-microsoft-ci}, which
provide distributed infrastructures to efficiently build massive
amounts of code and run tests.  Building server clusters is also a
popular mechanism to distribute testing workloads.  For example, as of
August 2013, the Groupon PWA system, which powers the
\url{groupon.com} website, included over 19K tests.  To run all those
tests under 10m, Groupon used a cluster of 4 computers with 24 cores
each~\cite{kim-etal-fse2013}.

At large organizations, the alternative of renting cloud
services\footnote{List of popular cloud services:
  \url{https://clutch.co/cloud}} or even building proprietary
infrastructures for running tests is a legitimate approach to mitigate
the regression testing problem.  However, for projects with low
budgets and yet relatively heavy testing workloads, this solution may
not be economically viable.  The proliferation of multi-core CPUs in
commodity hardware and the popularization of testing frameworks with a
rich support for parallelization (see Section~\ref{sec:modes}) enables
test suites to increase CPU usage.  This paper reports on an empirical
study we conducted to analyze importance of low-level parallelization
(\ie{}, parallel features available within each machine) to speedup
testing of open-source projects.  This is a relevant problem given the
tremendous popularity of open-source development and regression
testing research.

The dimensions of analysis in this study are as follows.

\begin{itemize}
\item \textbf{Prevalence of long-running test suites.}
\item \textbf{Usage of test suite parallelization.}  
\item \textbf{Impact (and issues) of parallelization.}  
\end{itemize}  

%% papers also indicate the important of speeding up the testing process
%% in other industrial domain, e.g., in 
%% \Mar{Ask Milos if he can share stories on how prevalent regression
%%   testing is at Microsoft and Google, if he can explain how they run
%%   tests, and how prevalent is parallelization (in contrast to
%%   regression testing).}

%Motivated by this potential gap in regression testing,
%% More specifically, we studied how often long-running test suites occur
%% in this setting, how frequently parallelization features are used, if
%% not used why, and what are the associated drawbacks.

%% To run each test suite, we used a
%% 16GB memory Intel i7 machine\Comment{ i7-4790 Intel processor} with
%% eight virtual CPUs (four cores with two native threads each) and the
%% default Maven configuration of each project.

%% RQ1 + RQ2
We selected \numSubjs{} popular Java projects from \github{}
containing Maven build files~\cite{maven} to assess how prevalent
long-running test suites are.  Section~\ref{sec:eval} details our
methodology to select subjects and to isolate our experiments from
environmental noise.  In summary, results indicate that $\sim$21\% of
the test suites take at least 1m to run and $\sim$8\% of the test
suites take at least 5m to run.  Considering all the \numMedLong{}
projects (\percentMedLongRunning{} of
\numSubjs{})\Fix{$\leftarrow$this is not right. check macros.} in the
$>$1m group, the average execution time is \averageMedLongRunning{}.
Results also show that individual tests are typically short-running,
taking often less than half a second to run.  Furthermore, we found
that only in rare cases few test cases monopolize execution cost
associated with each test suite.  Overall, these results suggest that
test suite parallelization has the potential to optimize these test
suites.

\Mar{missing connection. why parallelism?}  From these results we
investigated (2) how frequently the projects we considered use
parallelization to speedup test runs.  Our results indicate that
\percentParallelForLongRunning{} of long-running test suites do use
parallelism to speedup execution.  Given the popularity of this
solution, we further studied: (3) what are the causes of high
execution cost in individual tests (CPU vs. IO) and (4) how uniformly
cost is distributed across tests.  These questions help to assess the
impact of parallelization in test suite execution.  Intuitively,
IO-intensive test suites and test suites with uneven distribution of
cost per test are factors that limit the benefits of parallelization.
Results indicate that \Fix{...}  Finally, we investigated (5) what are
the limitations related to parallelization that could justify adoption
resistance.

\Fix{--------------}

\Mar{what about free services (jenkins)?  how much can you scale
  execution and how expensive would that be?}

To illustrate the importance of parallel test execution, \Jbc{TODO -
Write a paragraph motivating this paper.}

This paper reports an empirical study to evaluate the impact of
parallelization options on test execution speedup \Fix{...}\Jbc{TODO -
Summary of the contributions of this paper} .

%%  LocalWords:  parallelization multicore JUnit TestNG NUnit XXm YYm
%%  LocalWords:  Groupon parallelizing multi JVMs CPUs JVM Milos TODO
%%  LocalWords:  Ekstazi github CloudBuild PWA groupon criticality

 	
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
%%  LocalWords:  jenkins
