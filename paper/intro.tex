\section{Introduction}

%% . which can disrupt the development
%% process~\cite{hilton-etal-ase2016}.\Comment{  This is often referred to as the
%% ``regression testing problem''.}

As software evolves it is expected that the number of tests and the
length of test runs increase.  Both components can add up to the
aggregate cost of running a test suite.  Dealing with high testing
costs is an important problem in software engineering research and
industrial practice.

Several approaches have been proposed in the research literature to
address the regression testing problem, with the focus mainly on test
suite minimization, prioritization, reduction, and
selection~\cite{yoo-harman-stvr2012}.  In industry, the focus has been
mainly on distributing the testing workload.  Evidence of this are the
Google TAP system~\cite{google-tap,google-ci} and the Microsoft
CloudBuild system~\cite{prasad-shulte-ieee-microsoft-ci}, which
provide distributed infrastructures to efficiently build massive
amounts of code and run tests.  Building server clusters is also a
popular mechanism to distribute testing workloads.  For example, as of
August 2013, the Groupon PWA system, which powers the
\url{groupon.com} website, included over 19K tests.  To run all those
tests under 10m, Groupon used a cluster of 4 computers with 24 cores
each~\cite{kim-etal-fse2013}.

At large organizations, the alternative of renting cloud
services\footnote{List of popular hosting cloud services:
  \url{https://clutch.co/cloud}} or even building proprietary
infrastructures to running tests is a legitimate approach to mitigate
the regression testing problem.  However, for projects with low
budgets and yet relatively heavy testing workloads, this solution may
not be economically viable.  For these cases, the use of commodity
hardware (\eg{}, existing workstations), emerges as an attractive
solution for running tests.  Furthermore, the proliferation of
multi-core CPUs and the increasing popularization of testing
frameworks and build systems, which today provide mature support for
parallelization, enable test execution speedups through increased CPU
usage~(see Section~\ref{sec:modes}).  These two elements~---~demand
for cost-effective test execution and supply of testing
infrastructure~---~led us to investigate if and how parallelization
features from testing frameworks and build systems are used in
practice.

This paper reports on an empirical study we conducted to analyze the
impact of low-level parallelization to speedup testing in open-source
projects.  This is a relevant problem given the tremendous popularity
of open-source development\Mar{Fan Long
  (http://people.csail.mit.edu/fanl/) often uses a plot to show the
  exponential rise of projects in github.  Please check if you can
  find a reference to that or ask Fan Long what source he used (maybe
  browsed with public API).} and regression testing
research~\cite{yoo-harman-stvr2012}.  The dimensions of analysis we
considered in this study are as follows.

\begin{enumerate}
\item \textbf{Prevalence of long-running test suites.}
\item \textbf{Usage of test suite parallelization.}  
\item \textbf{Speedups of parallelization.}
\item \textbf{Issues versus benefits on using parallelization modes.}
\end{enumerate}

Each dimension focuses on one aspect of our study.  The first
dimension measures to which extent open-source projects contain time
costly test suites.  In the limit, parallelization will be fruitless
if all project contain short-running test suites The second dimension
measures how often open-source projects, irrespective of their
associated testing costs, use parallelization schemes.  This dimension
is concerned with popularity of parallelization.  The third aspect
evaluates the observed impact of parallelization on cost.  Finally,
the last dimension evaluates the issues and benefits associated with
running test suites with different parallel configuration (/modes).
Overall, the study of these dimensions help us layout the current
state-of-the-practice in usage of parallelization in open-source
projects.

\Mar{organize according to each of these dimensions...$\rightarrow$}

%% papers also indicate the important of speeding up the testing process
%% in other industrial domain, e.g., in 
%% \Mar{Ask Milos if he can share stories on how prevalent regression
%%   testing is at Microsoft and Google, if he can explain how they run
%%   tests, and how prevalent is parallelization (in contrast to
%%   regression testing).}

%Motivated by this potential gap in regression testing,
%% More specifically, we studied how often long-running test suites occur
%% in this setting, how frequently parallelization features are used, if
%% not used why, and what are the associated drawbacks.

%% To run each test suite, we used a
%% 16GB memory Intel i7 machine\Comment{ i7-4790 Intel processor} with
%% eight virtual CPUs (four cores with two native threads each) and the
%% default Maven configuration of each project.

%% RQ1 + RQ2
We selected \numSubjs{} popular Java projects from \github{}
containing Maven build files~\cite{maven} to assess how prevalent
long-running test suites are.  Section~\ref{sec:eval} details our
methodology to select subjects and to isolate our experiments from
environmental noise.  In summary, results indicate that $\sim$21\% of
the test suites take at least 1m to run and $\sim$8\% of the test
suites take at least 5m to run.  Considering all the \numMedLong{}
projects in the $>$1m group (\percentMedLongRunning{} of
\numSubjs{})\Fix{$\leftarrow$this is not right. check macros.}, the
average execution time is \averageMedLongRunning{}.  Results also show
that individual tests are typically short-running, taking often less
than half a second to run.  Furthermore, we found that only in rare
cases few test cases monopolize execution cost associated with each
test suite.  Overall, these results suggest that test suite
parallelization has the potential to optimize these test suites.

%%RQ3
Given the high execution cost associated with a significant number of
\github{} projects, we decided to investigate usage of test
suite parallelization in practice.  It is important to note that modern build
systems (\eg{}, Maven~\cite{maven}) offer parallelization options to
accelerate test execution (see Section~\ref{sec:modes}).  To find how
popular these features are in practice, we first analyzed build files
\emph{statically}.  Considering the $>$1m group of projects
(\numMedLong{} in total), we found that 49\% (41/\numMedLong{}) of
them use some parallelization option.  Considering those projects that
take more than 5m to run (\numLong{} in total), usage of parallelism
increases to 59\% (19/\numLong{}).  Furthermore, we found that
``forking'' virtual machines was the most prevalent parallel mode used
in practice.  This mode is used twice as much as any other mode used.
Important to note that ``forking VMs'' is perhaps the simplest of the
parallelization modes~--~it is provided by the build system as opposed
to the testing framework.  This result suggests that datarace
flakiness~\cite{luo-etal-fse2014} may be a concern to users as
``forking'' does not exploit thread-level concurrency within each VM,
which can create contention on data reachable from the static
area~\cite{bell-kaiser-icse2014,bell-etal-esecfse2015}.  Instead, it
creates independent processes (\ie{}, Java VM instances) and executes
tests sequentially within each process. \Mar{why 32-19 did not use
  parallelization?}

\Fix{...Discuss impact...}\Mar{what about free services (jenkins)?
  how much can you scale execution and how expensive would that be?}

%% \Mar{missing connection. why parallelism?}  From these results we
%% investigated (2) how frequently the projects we considered use
%% parallelization to speedup test runs.  Our results indicate that
%% \percentParallelForLongRunning{} of long-running test suites do use
%% parallelism to speedup execution.  Given the popularity of this
%% solution, we further studied: (3) what are the causes of high
%% execution cost in individual tests (CPU vs. IO) and (4) how uniformly
%% cost is distributed across tests.  These questions help to assess the
%% impact of parallelization in test suite execution.  Intuitively,
%% IO-intensive test suites and test suites with uneven distribution of
%% cost per test are factors that limit the benefits of parallelization.
%% Results indicate that \Fix{...}  Finally, we investigated (5) what are
%% the limitations related to parallelization that could justify adoption
%% resistance.

%% To illustrate the importance of parallel test execution, \Jbc{TODO -
%% Write a paragraph motivating this paper.}

%% This paper reports an empirical study to evaluate the impact of
%% parallelization options on test execution speedup \Fix{...}\Jbc{TODO -
%% Summary of the contributions of this paper} .

%%  LocalWords:  parallelization multicore JUnit TestNG NUnit XXm YYm
%%  LocalWords:  Groupon parallelizing multi JVMs CPUs JVM Milos TODO
%%  LocalWords:  Ekstazi github CloudBuild PWA groupon criticality

 	
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
%%  LocalWords:  jenkins
