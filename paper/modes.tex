\section{Parallel Execution of Test Suites}
\label{sec:modes}

\begin{figure}[t!]
  \centering
  \includegraphics[width=0.35\textwidth]{figs/parallel-levels.pdf}
  \vspace{-1ex}
  \caption{\label{fig:levels}Levels of parallelism.}
\end{figure}

%\Mar{add a sentence to introduce this section at a higher abstraction
%  level.}

This section provides some background on parallel test execution.

Parallelism in test execution can be obtained at different levels.
Figure~\ref{fig:levels} illustrates relevant levels for this paper.
The highest level indicates parallelism that can be obtained through
different machines on the network.  For examples, using machines from
a cloud service.  The machine space sits under the ``network space'',
and is responsible to provide low-level parallelism.  In that case,
computation can be offloaded on different CPUs within a machine and on
different threads within each CPU.  Note that all these levels are
complementary.  For the scenario of large IT organizations, for
example, lower-level parallelization schemes could leverage the
computing power of server nodes in addition to the aggregate
processing power of the farm.

%% Lower-level parallelism fits
%% particularly well smaller organizations (/projects) with relatively
%% high testing costs but lower budgets.

This paper focuses at lower-level parallelism, which can be enabled
through build systems and testing frameworks.  Given the proliferation
of multi-core machines it is not surprising that testing frameworks
provide today support for parallel test
execution~\cite{junit-org,testng,nunit}.  Build systems wrap parallel
features offered by testing frameworks to facilitate the use of such
technology~\cite{maven-surefire-plugin}.  In the following we elaborate
relevant features of these components focusing on Java, Maven, and
JUnit but the discussion can be generalized to other languages, build
systems, and testing frameworks.


\Comment{
    Unfortunately, these solutions can't be used out-of-the-box:
    unrestricted parallel execution of tests can produce
    non-deterministic results as developers typically do not provision
    protection to concurrent accesses originated from arbitrary program
    points (\ie{}, tests).  We refer to this problem as Parallel
    Execution Flakiness (\pef{}).

    %% These solutions enable the
    %% use of commodity hardware to maximize CPU usage\footnote{In the case
    %%   of the Java language, for example, it is possible to explore
    %%   parallelism across and within JVMs.}.  

    To illustrate the importance of parallel test execution and
    the problem of \pef{} let's consider the case of the ``core'' module
    from the Apache Camel project~\cite{apache-camel-web}.  This module
    contains 5,679 test cases, declared in 2,356 test classes.  We ran
    those tests in a machine with 16GB of memory and 8 virtual CPUs (4
    cores with 2 native threads each).  Sequential test execution takes
    24m50s to run this test set.  Execution of the same test set takes
    2m28s when we configured parallel execution to fork a JVM per CPU and
    execute test classes, uniquely allocated to that JVM, sequentially but
    running test methods from each class in separate threads.  Note that
    this is an order of magnitude speedup (10.07x)\Fix{Need to understand
    why this is 10x as opposed to something closer to 7x - I didn't get
    your concern here}.  Unfortunately, due to \pef{}, $\sim$2\% (114 of
    5,679) of the tests fail when executed in parallel.  It is important
    to notice that the ratio of failures varies with the project as it
    depends on factors such as length of test cases and amount of shared
    state across tests.

    \pef{} is an important obstacle to enable parallel test execution.
    Conceptually, higher parallelization can result in higher chances of
    concurrency-related problems.  It is important to execute tests
    efficiently without sacrificing reliability
    \Fix{gap between pars?? What gap?}
}

\Mar{----------------------- estou aqui.}

\subsection{Testing Framework}
\label{sec:frameworks}

The list below shortly describes the choices to control parallelism
within a JVM.

\newcommand{\Seq}{L0}
\newcommand{\ParClassSeqMeth}{L1}
\newcommand{\SeqClassParMeth}{L2}
\newcommand{\ParClassParMeth}{L3}

\begin{itemize}
\item
    \textbf{Sequential (\Seq).}~This configuration results in
        sequential execution of test classes and their methods,
        according to a given order defined in the testing framework
        (\eg, the order of methods returned by Java Reflection
        API)~\cite{junit-test-order}. For JUnit, this is the default
        configuration.
\item
    \textbf{Sequential classes; parallel methods
        (\ParClassSeqMeth{}).}~This configuration results in the
        sequential execution of the test classes assigned to the JVM.
        However, within each class, test methods run in parallel. In
        JUnit, \emph{ParallelComputer} provides support to parallel
        execution: it instantiates a test runner with an
        \emph{ExecutorService} from the Java Concurrent API. Each test
        method is executed in a separated thread as the thread pool
        creates new threads on-demand and reuse them if any thread is
        available.
    \Comment{http://junit.org/junit4/javadoc/latest/src-html/org/junit/experimental/ParallelComputer.html#line.14}
\item
    \textbf{Parallel classes; sequential methods
        (\SeqClassParMeth{}).}~This configuration results in the
        parallel execution of test classes and sequential test
        methods. As in \ParClassSeqMeth, the test runner has a cached
        thread poll but instead of executing test methods from a
        single test class, the test suite runner executes classes in
        separated threads and methods sequentially within each thread.
\item
    \textbf{Parallel methods (\ParClassParMeth).}~This configuration
        results in the parallel execution of any test method from any
        class.  \Jbc{I need to confirm this but AFAIK this is how it
        happens} As in \SeqClassParMeth, classes execute on separated
        threads but test methods are also executed in parallel. More
        precisely, there is a thread pool to execute classes in
        separated threads (\ie, like in \ParClassSeqMeth) and, within
        each class runner, there is an \emph{ExecutorService} to run
        test methods in parallel (\ie, like in \SeqClassParMeth).
\end{itemize}

\Jbc{I have to understand better how Surefire executes tests. I'm
afraid it has its own wrapper classes and reuse JUnit core
functionalities. I'm saying this because JUnit does not offer a finer
control over thread numbers while this configuration is possible with
Surefire} For example, Figure~\ref{fig:surefire} illustrates how to
configure Maven to execute classes sequentially (default behavior) and
test methods in parallel. Although this configuration is defined in
the build file (\eg, \emph{pom.xml} on Maven), \Fix{these settings are
forwarded to the underlying testing framework (\eg, JUnit). In case of
JUnit,}

\begin{figure}[h!]
\centering
\scriptsize
\lstset{
    escapeinside={@}{@},
    numbers=left,xleftmargin=1em,frame=single,framexleftmargin=0.5em,
    basicstyle=\ttfamily\scriptsize, boxpos=c, numberstyle=\tiny,
    morekeywords={parallel, threadCount, perCoreThreadCount},
    deletekeywords={true}
}
\begin{lstlisting}
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <parallel>methods</parallel>
        <threadCount>2</threadCount>
        <perCoreThreadCount>true</perCoreThreadCount>
    </configuration>
</plugin>
\end{lstlisting}
\caption{\label{fig:surefire} Example of Maven Surefire configuration:
    test methods in parallel (\emph{parallel} parameter) using two
    threads (\emph{threadCount} parameter) per core (boolean flag
    \emph{perCoreThreadCount}).}
\end{figure}

\Fix{We need a par. providing rationale in to explain (points in
favor/against) these choices.}

\subsection{Build Systems}
Build systems, such as Maven\footnote{\url{maven.apache.org}},
typically provide the option to \emph{fork} JVM instances
proportionally to available cores in the machine.  If the option
``fork JVM'' is enabled, Maven will allocate a user-provided number of
JVM instances to each core in the machine and will allocate each test
class to exactly one JVM.  Note that there is no guarantee to
uniformly distribute load to each JVM given that the build system uses
classes as the unit to specify test tasks.\Fix{we need to know how
Maven allocates test classes to JVMs}
