\section{Anatomy of a \pef{} failure}

\Fix{...}

It is important to note that previous work investigated test flakiness
manifested in sequential executions [cite cite].  For example, a test
case can fail because an implicit ordering assumption from a
multi-threaded test was broken under a sequential execution of the
test suite.  \Fix{or a test case can fail...} Treating this source of
flakiness is important but orthogonal to this work: parallel execution
flakiness can arise even without sequential execution flakiness.

Modern build systems provide a means to reveal test flakiness.  The
typical approach is to execute the test suite multiple times and
iteratively mark as flaky those tests that produce both pass and
failing outputs.  More precisely, the process starts with the
developer determining a bound N for the number of re-executions of the
test suite.  Only tests that fail in one given iteration
(consequently, failed in all previous iterations) are scheduled for
re-execution in the next iteration.  At the end of the process, a test
is considered passing if it passes in the first iteration, a test is
considered failing if it fails in all iterations, and it is considered
flaky if it fails in all iterations but the last it executed.  The
process terminates when all tests eventually pass or when the bound N
is reached.  Note that every iteration runs a subset of the tests from
the previous iteration so execution cost is lower compared to
executing the entire test suite N times.  To note that this iterative
process is supported by the popular maven surefire
plugin~\cite{maven-surefire-plugin}.\Fix{others?  mention which
  flag/parameter...}  Ideally, one would like to eliminate \pef{}s and
avoid the need for re-executing the test suite multiple times.
