\section{Anatomy of a \pef{} failure}

It is important to note that previous work investigated test flakiness
manifested in sequential executions\Fix{cite cite}.  For example, a
test case can fail because a timing assumption of an asynchronous test
was broken.  Treating this source of flakiness is important but
orthogonal to this work: parallel execution flakiness can arise even
without sequential execution flakiness.  In the following we explain
how \pef{}s come to be.

\Fix{...}

\noindent\textbf{Detecting flakiness.}  Modern build systems provide
mechanisms to reveal test flakiness. The typical approach is to
iteratively re-execute the test suite marking as flaky those tests
that produce both pass and failing outputs.  Considering the
Maven\Fix{is this maven or maven's surefire
  plugin~\cite{maven-surefire-plugin}?}  build system, the process
starts with the developer determining a bound N for the number of
re-executions of the test suite.  Only tests that fail in one given
iteration are scheduled for re-execution in the next iteration.  At
the end of the process, a test is considered passing if it passes in
the first iteration, a test is considered failing if it fails in all
iterations, and it is considered flaky if it fails in all iterations
but the last it executed.  The process terminates when all tests
eventually pass or when the bound N is reached.  Note that every
iteration runs a subset of the tests from the previous iteration so
execution cost is lower compared to executing the entire test suite N
times.

\Fix{Ideally, one would like to eliminate \pef{}s and avoid the need
  for re-executing the test suite multiple times.}
